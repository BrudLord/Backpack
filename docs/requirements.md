## Функциональные требования

1.  Реализация [алгоритмов](algorithms-details.md).

2.  **Унифицированный интерфейс `KnapsackSolver`:**

    *   Все алгоритмы должны реализовывать общий интерфейс.
    *   Интерфейс должен предоставлять методы:
        *   Получение имени алгоритма.
        *   Решение задачи для заданного рюкзака.
        *   Возврат оптимальной стоимости (или приближённого значения для FPTAS и жадного).

3.  **Проведение экспериментов:**

    *   **Сравнение алгоритмов:**
        *   Запуск нескольких (или всех) алгоритмов на одном и том же наборе данных.
        *   Возможность задания списка алгоритмов для сравнения.
    *   **Серии экспериментов:**
        *   Проведение серий экспериментов с изменяемыми параметрами:
            *   Количество предметов (n).
            *   Диапазоны весов предметов.
            *   Диапазоны стоимостей предметов.
            *   Вместимость рюкзака.
            *   Количество генераций наборов данных для каждого набора параметров.
    *   **Автоматическое сохранение результатов:**
        *   Время выполнения (для каждого запуска и усреднённые метрики).
        *   Потребление памяти (если возможно и имеет смысл для конкретного алгоритма).
        *   Точность:
            *   Для точных алгоритмов: процент правильных ответов.
            *   Для приближённых: относительная ошибка по сравнению с лучшим решением, найденным точными алгоритмами (если применимо) или известным оптимальным решением.

4.  **Генерация и управление входными данными:**

    *   **Загрузка конфигурации:**
        *   Загрузка параметров эксперимента (включая список алгоритмов, параметры генерации данных, параметры бенчмаркинга) из JSON-файлов.
    *   **Генерация данных:**
        *   Генерация случайных наборов предметов (веса и стоимости) в заданных диапазонах.
        *   Создание экземпляров задачи о рюкзаке с заданной вместимостью.

5.  **Анализ и сбор метрик:**

    *   **Сбор метрик для каждого алгоритма и серии экспериментов:**
        *   Среднее время выполнения.
        *   Стандартное отклонение времени выполнения.
        *   Медиана времени выполнения.
        *   Медианное абсолютное отклонение времени выполнения (MAD).
        *   Точность (как описано в п. 3).
    *   **Бенчмаркинг (Criterion):**
        *   Использование библиотеки `Criterion` для точных замеров производительности.
        *   Настраиваемые параметры бенчмаркинга (через конфигурационный файл):
            *   Размер выборки.
            *   Время прогрева.
            *   Количество повторных измерений.

6.  **Вывод результатов:**

    *   **Генерация отчётов:**
        *   Таблицы в формате Markdown с результатами экспериментов (включая метрики производительности и точности).
        *   Графики производительности (SVG):  зависимость времени выполнения от количества предметов, вместимости и, возможно, других параметров.
    *   **Сохранение результатов:**
        *   Сохранение отчётов (Markdown) и графиков (SVG) в файлы.
        *   Опционально: перемещение графиков в отдельную директорию (например, `assets`).

7.  **Логирование:**

    *   Запись результатов выполнения экспериментов (в Markdown файл, опционально дублирование в консоль).
    *   Информация о ходе выполнения (запуск алгоритмов, генерация данных).
    *   Сообщения об ошибках (например, ошибки при работе с файловой системой, некорректные входные данные).

8. **CLI (Command Line Interface)**:
    * Запуск отдельных алгоритмов.
    * Запуск серии экспериментов.

## Нефункциональные требования

1.  **Производительность:**

    *   **API библиотеки:**  Время отклика метода solve должно быть приемлемым.  Точное время зависит от алгоритма и размера входных данных.
    *  Для FPTAS и жадного алгоритма n <= 10 000.

2.  **Масштабируемость:**

    *   Библиотека должна поддерживать обработку данных для *приближённых* методов с количеством предметов до 10 000.
    *   Параметры экспериментов (количество предметов, диапазоны весов/стоимостей, вместимость) должны быть настраиваемыми.

3.  **Расширяемость:**

    *   Добавление новых алгоритмов должно осуществляться без изменения кода, отвечающего за проведение экспериментов, сбор метрик и вывод результатов.
    *   Возможность добавления новых форматов вывода результатов (помимо Markdown и SVG) без модификации ядра библиотеки.

4.  **Надёжность:**

    *   **Обработка ошибок:**
        *   Некорректные входные данные (отрицательные веса/стоимости/вместимость, несоответствие типов).
        *   Ошибки при загрузке/сохранении файлов (отсутствие файла, неверный формат, проблемы с доступом).
        *   Нехватка памяти (генерирование и обработка исключений, если применимо).
    *   **Валидация:**  Входные данные (параметры генерации, конфигурация эксперимента) должны проходить валидацию перед использованием.

5.  **Документация:**

    *   Полная документация публичного API (структуры данных, интерфейсы, функции, типы ошибок).
    *   Примеры использования библиотеки (решение задачи отдельными алгоритмами, проведение экспериментов).
    *   Комментарии к коду, объясняющие сложные моменты и неочевидные решения.

6.  **Удобство использования:**

    *   Простая установка и настройка.
    *   Понятный API для разработчиков.
    *   Информативные и понятные сообщения об ошибках.
    *   Конфигурирование через JSON-файлы.

7.  **Совместимость:**

    *   Поддержка основных операционных систем (Linux, macOS, Windows).
    *   Поддержка версий Rust, начиная с 1.65.

8.  **Тестирование:**

    *   **Модульные тесты:** 100% покрытие кода модульными тестами для ядра библиотеки (реализации алгоритмов, модуль генерации данных, сервис экспериментов).
    *   **Тесты экспериментатора:**  Проверка корректности проведения экспериментов, сбора метрик и генерации отчётов.
    *   **Бенчмарки:** Наличие бенчмарков (с использованием `Criterion`) для основных алгоритмов.
